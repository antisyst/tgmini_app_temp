Documentations:

@telegram-apps/sdk-react

React JS bindings for client SDK. Includes hooks, components and utilities for comfortable usage of React JS on the Telegram Mini Apps platform.

Installation
Before anything else, it is assumed that you have already installed the react package, as it is a peer dependency of this package.

pnpm i @telegram-apps/sdk-react

SDKProvider

SDKProvider is a component responsible for providing the SDK functionality. It accepts such properties as acceptCustomStyles: boolean and debug: boolean. Both of them are optional.

The acceptCustomStyles property is responsible for accepting custom styles from the web version of Telegram.

The debug property is responsible for enabling a debug mode.

jsx
import { SDKProvider } from '@telegram-apps/sdk-react';

/**
 * Root component for the whole project.
 */
export function Root() {
  return (
    <SDKProvider acceptCustomStyles debug>
      <div>My application!</div>
    </SDKProvider>
  );
}

Hooks
For better understanding, each component hook uses its own component-related init function. If the init function returns a non-promise value, the hook will instantly retrieve it. If the init function is asynchronous, the hook will return an undefined value while the component is still initializing. Then, it will be updated to the initialized value.

All component hooks in this package are divided into two parts:

Retrieving the actual init function value. These hooks are non-suffixed, like useBackButton.
Retrieving a meta item related to the init function value. These hooks include a suffix such as Raw, like useBackButtonRaw.
The first category of hooks returns the actual init function value. They throw an error if something goes wrong during component initialization.

The second category of hooks returns an object containing the initialization process information. Here is the object shape:

ts
export interface SDKContextItem<T> {
  /**
   * This item execution result. The property may be missing
   * in case the execution is async.
   */
  result?: T;
  /**
   * Function to clean up item side effects.
   */
  cleanup?(): void;
  /**
   * An error occurred during execution.
   */
  error?: unknown;
}
Using the second category of hooks, you can extract an error without throwing it.

Here is the complete usage example:

ts
import {
  useBackButton,
  useBackButtonRaw,
  useViewport,
  useViewportRaw,
  useBiometryManagerRaw,
} from '@telegram-apps/sdk-react';
import { useEffect } from 'react';

// BackButton initializes synchronously. So, bb will be 
// the BackButton instance.
const bb = useBackButton();

// Viewport is being initialized asynchronously, so signal may return undefined.
// After some time it will receive a valid value.
const vp = useViewport();

useEffect(() => {
  console.log(vp); // will be undefined and then Viewport instance.
}, [vp]);

const bm = useBiometryManagerRaw();

useEffect(() => {
  if (bm.error) {
    console.error('Something went wrong for BiometryManager', bm.error);
  }
}, [bm]);
SSR
This package also supports SSR mode, widely used in popular frameworks like Next.js. When using package hooks on the server side, you must pass true as the first argument. This notifies the hook that server-side mode is enabled. Not specifying this value and calling the hook on the server side will lead to an error.

Server-side mode returns undefined for each component hook on the server side and also before the current component is mounted. This is required for persistence between trees rendered on the server and client sides.

ts
import { useBackButton } from '@telegram-apps/sdk-react';
import { useEffect } from 'react';

function Component() {
  const bb = useBackButton(true); // will be undefined or BackButton.

  useEffect(() => {
    if (bb) {
      // Here we can safely work with the BackButton.
    }
  }, [bb]);
}
HOCs
All package Higher Order Components utilize the hooks described previously. The usage is rather simple:

ts
import { withBackButton } from '@telegram-apps/sdk-react';
import { useEffect } from 'react';

const A = withBackButton('bb', false, ({ bb }) => {
  useEffect(() => {
    bb.show();
  }, [bb]);
  return null;
});

const B = withBackButton('bb', true, ({ bb }) => {
   useEffect(() => {
      bb && bb.show();
   }, [bb]);
   return null;
});
As the first argument, you must pass a value responsible for the component property name receiving a hook result. The second argument is SSR flag mode, which will be passed to the hook, used internally.

Hooks and HOCs List
Hook and HOC (Raw)	Hook and HOC (Result)	Returned value
useBackButtonRaw, withBackButtonRaw	useBackButton, withBackButton	BackButton
useBiometryManagerRaw, withBiometryManagerRaw	useBiometryManager, withBiometryManager	BiometryManager or undefined
useClosingBehaviorRaw, withClosingBehaviorRaw	useClosingBehavior, withClosingBehavior	ClosingBehavior
useCloudStorageRaw, withCloudStorageRaw	useCloudStorage, withCloudStorage	CloudStorage
useHapticFeedbackRaw, withHapticFeedbackRaw	useHapticFeedback, withHapticFeedback	HapticFeedback
useInitDataRaw, withInitDataRaw	useInitData, withInitData	InitData
useInvoiceRaw, withInvoiceRaw	useInvoice, withInvoice	Invoice
useLaunchParams	Launch params
useMainButtonRaw, withMainButtonRaw	useMainButton, withMainButton	MainButton
useMiniAppRaw, withMiniAppRaw	useMiniApp, withMiniApp	MiniApp
usePopupRaw, withPopupRaw	usePopup, withPopup	Popup
useQRScannerRaw, withQRScannerRaw	useQRScanner, withQRScanner	QRScanner
useSettingsButtonRaw, withSettingsButtonRaw	useSettingsButton, withSettingsButton	SettingsButton
useSwipeBehaviorRaw, withSwipeBehaviorRaw	useSwipeBehavior, withSwipeBehavior	SwipeBehavior
useThemeParamsRaw, withThemeParamsRaw	useThemeParams, withThemeParams	ThemeParams
useUtilsRaw, withUtilsRaw	useUtils, withUtils	Utils
useViewportRaw, withViewportRaw	useViewport, withViewport	Viewport or undefined
Template
We have already created a template for React JS that utilizes the current package, so you can use it.

#Components
Init
According to the design of this package, the developer has complete control over its lifecycle, including the initialization process. This means that there are no pre-initialized global components available for use by the developer. They must create the components themselves.

To simplify the developer's workflow, the package includes special functions prefixed with the init string. These functions return a tuple, containing an instance of the initialized component and a cleanup function, removing all side effects created by this init function.

Here is an example:

typescript
import { initBackButton, initMainButton } from '@telegram-apps/sdk';

const [mb, cleanupMb] = initMainButton();
const [bb, cleanupBb] = initBackButton();

// Clicking the MainButton hides it and shows the BackButton.
mb.on('click', () => {
  mainButton.hide();
  backButton.show();
});

// Clicking the BackButton hides it and shows the MainButton.
bb.on('click', () => {
  mainButton.show();
  backButton.hide();
});

// Configure the MainButton.
mb
  .setBgColor('#ff0000')
  .setTextColor('#ffffff')
  .setText('Expand')
  .enable()
  .show();

// When we don't need BackButton and MainButton anymore, we can 
// perform a cleanup. After calling a cleanup, the initialized 
// component will not receive any events.
cleanupMb();
cleanupBb();
INFO

Take note that some components cannot be instantiated synchronously as long as there is no information about them locally. Use each component's documentation to learn more about how the component initializes.

Events
Component instances use the common way of events listening through the on and off methods. Here is the example with the BackButton component:

typescript
import { initBackButton } from '@telegram-apps/sdk';

const [bb] = initBackButton();

// Clicking the BackButton hides it and shows the MainButton.
bb.on('click', () => {
  console.log('BackButton clicked.');
});
You can find the list of supported events in components own documentations.

Methods Support
Almost each component is capable of checking whether its method is supported by the current Mini Apps version or not. To check if some methods are supported, developer should use the component instance supports() function. For example:

typescript
import { BackButton } from '@telegram-apps/sdk';

let bb = new BackButton('6.0', ...);
bb.supports('show'); // false

bb = new BackButton('6.3', ...);
bb.supports('hide'); // true
Some of the components support an additional method supportsParam which allows checking if method parameter is supported:

typescript
import { Utils } from '@telegram-apps/sdk';

let utils = new Utils('6.0', ...);
utils.supportsParam('openLink.tryInstantView'); // false

utils = new Utils('6.10', ...);
utils.supportsParam('openLink.tryInstantView'); // true
TIP

It is recommended to use this functionality before calling some component method as long as this will make developer sure, it will work. The list of supported methods by components is described in each component documentation.

#BackButton
Implements Telegram Mini Apps Back Button.

Initialization
To initialize the component, use the initBackButton function:

typescript
import { initBackButton } from '@telegram-apps/sdk';

const [backButton] = initBackButton();
Showing and Hiding
To show and hide BackButton, it is required to use show() and hide() methods. These methods update the button's isVisible property:

typescript
backButton.show();
console.log(backButton.isVisible); // true  

backButton.hide();
console.log(backButton.isVisible); // false
Events
List of events, which could be tracked:

Event	Listener	Triggered when
click	() => void	Back Button was clicked
change	() => void	Something in component changed
change:isVisible	(value: boolean) => void	isVisible property changed
Methods Support
List of methods, which could be used in support checks: show and hide


#BiometryManager

Initialization
To initialize the component, use the initBiometryManager function:

typescript
import { initBiometryManager } from '@telegram-apps/sdk';

const [biometryManager] = initBiometryManager();
INFO

Since BiometryManager can't be instantiated synchronously, this function returns a promise that will be resolved when the biometry manager data is retrieved.

Authenticating
To authenticate a user, use the authenticate method:

ts
bm
  .authenticate({ reason: 'Authorize to unlock the storage' })
  .then(token => {
    console.log('Token received', token);
  });
This method accepts an optional reason: string property with length up to 128 symbols.

Opening Settings
To open a modal window with biometry settings, use the openSettings method:

ts
bm.openSettings();
In this modal, a user is capable of turning on and off the biometry functionality.

Requesting Access
To request a permission to use the biometry, use the requestAccess method:

ts
bm
  .requestAccess({ reason: 'Authorize to start using biometry' })
  .then(accessGranted => {
    console.log('Access granted', accessGranted);
  });
As well as the authenticate method, it accepts an optional reason: string property with length up to 128 symbols.

Updating Biometry Token
To update a token, stored in the secure storage, use the updateToken method:

ts
bm
  .updateToken({ token: 'My token' })
  .then(status => {
    console.log('Token updated', status);
  });
This method returns a promise with the execution status.

Events
List of events, which could be tracked:

Event	Listener	Triggered when
change:accessGranted	(value: boolean) => void	accessGranted property changed
change:accessRequested	(value: boolean) => void	accessRequested property changed
change:available	(value: boolean) => void	available property changed
change:deviceId	(value: string) => void	deviceId property changed
change:tokenSaved	(value: boolean) => void	tokenSaved property changed
change:token	(value: string) => void	token property changed
change:biometryType	(value: BiometryType) => void	biometryType property changed
Methods Support
List of methods, which could be used in support checks: auth, openSettings, requestAccess and updateToken.

#ClosingBehavior
Implements Telegram Mini Apps closing behavior functionality.

Initialization
To initialize the component, use the initClosingBehavior function:

typescript
import { initClosingBehavior } from '@telegram-apps/sdk';

const [closingBehavior] = initClosingBehavior();
Closing Confirmation
To enable and disable closing confirmation, it is required to use enableConfirmation() and disableConfirmation() methods. These methods update isConfirmationNeeded property:

typescript
closingBehavior.enableConfirmation();
console.log(closingBehavior.isConfirmationNeeded); // true  

closingBehavior.disableConfirmation();
console.log(closingBehavior.isConfirmationNeeded); // false
Events
List of events, which could be tracked:

Event	Listener	Triggered when
change	() => void	Something in component changed
change:isConfirmationNeeded	(value: boolean) => void	isConfirmationNeeded property changed

#CloudStorage
Implements functionality related to Telegram Mini Apps cloud storage.

Initialization
To initialize the component, use the initCloudStorage function:

typescript
import { initCloudStorage } from '@telegram-apps/sdk';

const cloudStorage = initCloudStorage();
Setting Items
To save a value in the cloud storage, it is required to use the set method:

typescript
cloudStorage
  .set('my-key', 'my-value')
  .then(() => console.log('Item saved'));
Getting Items
To get values by keys, it is required to use get method, which acquires both single string value and array of string values:


Single value

Array of values
typescript
cloudStorage
  .get('my-key')
  .then((value) => {
    console.log(value);
    // Output: 'my-value'
  });

cloudStorage
  .get('non-existent')
  .then((value) => {
    console.log(value);
    // Output: ''
  });
This method returns empty strings for those keys, which don't exist in the cloud storage.

Getting Keys
To retrieve all registered keys in the cloud storage, it is required to use the getKeys method:

typescript
cloudStorage
  .getKeys()
  .then((keys) => {
    // Will be ['my-key'].
    console.log('Keys are', keys);
  })
Deleting Items
To delete items in the cloud storage, it is required to use delete method. This method allows deleting both single and multiple items:


Single item

Multiple items
typescript
cloudStorage
  .delete('my-key')
  .then(() => console.log('Key was deleted'));
Methods Support
List of methods, which could be used in support checks: delete, get, getKeys and set


#HapticFeedback
Implements Telegram Mini Apps haptic feedback functionality.

Initialization
To initialize the component, use the initHapticFeedback function:

typescript
import { initHapticFeedback } from '@telegram-apps/sdk';

const [hapticFeedback] = initHapticFeedback();
Notifications
HapticFeedback supports 3 types of haptic events - impactOccurred, notificationOccurred and selectionChanged.

impactOccurred
A method tells that an impact occurred. The Telegram app may play the appropriate haptics based on style value passed. Style of impact occurred haptic event:

light, indicates a collision between small or lightweight UI objects
medium, indicates a collision between medium-sized or medium-weight UI objects
heavy, indicates a collision between large or heavyweight UI objects
rigid, indicates a collision between hard or inflexible UI objects
soft, indicates a collision between soft or flexible UI objects
typescript
haptic.impactOccurred('medium');
notificationOccurred
A method tells that a task or action has succeeded, failed, or produced a warning. The Telegram app may play the appropriate haptics based on type value passed. Type of notification occurred type event.

error, indicates that a task or action has failed,
success, indicates that a task or action has completed successfully,
warning, indicates that a task or action produced a warning.
typescript
haptic.notificationOccurred('success');
selectionChanged
A method tells that the user has changed a selection.

typescript
haptic.selectionChanged();
Methods Support
List of methods, which could be used in support checks: notificationOccurred, impactOccurred and selectionChanged

#InitData
The component which is responsible for implementing the Telegram Mini Apps init data.

Initialization
To initialize the component, use the initInitData function:

typescript
import { initInitData } from '@telegram-apps/sdk';

const [initData] = initInitData();
Properties
authDate
Type: Date

Init data generation date.

canSendAfter
Type: number, optional

The number of seconds after which a message can be sent via the method answerWebAppQuery.

canSendAfterDate
Type: Date, optional

Date after which it is allowed to call the answerWebAppQuery method.

chat
Type: Chat, optional

An object containing data about the chat where the bot was launched via the attachment menu. Returned for supergroups, channels and group chats – only for Mini Apps launched via the attachment menu.

chatType
Type: 'sender' | 'private' | 'group' | 'supergroup' | 'channel' | string, optional

The type of chat from which Mini App was opened.

chatInstance
Type: string, optional

A global identifier indicating the chat from which Mini App was opened. Returned only for applications opened by direct link.

hash
Type: string

A hash of all passed parameters, which the bot server can use to check their validity.

queryId
Type: string, optional

A unique identifier for the Mini App session, required for sending messages via the answerWebAppQuery method.

receiver
Type: User, optional

An object containing data about the chat partner of the current user in the chat where the bot was launched via the attachment menu. Returned only for private chats and only for Mini Apps launched via the attachment menu.

startParam
Type: string, optional

The value of the startattach parameter, passed via link. Only returned for Mini Apps when launched from the attachment menu via link.

user
Type: User, optional

An object containing data about the current user.

#Invoice
Implements Telegram invoices functionality.

Initialization
To initialize the component, use the initInvoice function:

typescript
import { initInvoice } from '@telegram-apps/sdk';

const invoice = initInvoice();
Opening Invoice
To open an invoice, it is required to use the open method. This method allows opening invoices using their URLs or slugs.

Opening an invoice in URL mode requires passing the second argument equal to url, so the method will interpret the passed value as a URL.

To interpret the passed value as a slug, omit the second argument.


Using slug

Using URL
typescript
invoice
  .open('abIIks213')
  .then((status) => {
    // Output: 'paid'
    return console.log(status);
  });
INFO

Note that slug is a part of the string which is placed after the $ symbol. So, having the $abcdefghi value returned from Telegram Bot API, you must call the open method using the abcdefghi value, or a complete URL (https://t.me/invoice/abcdefghi or https://t.me/$abcdefghi).

Events
List of events, which could be tracked:

Event	Listener	Triggered when
change	() => void	Something in component changed
change:isOpened	(value: boolean) => void	isOpened property changed
Methods Support
List of methods, which could be used in support checks: open

#MainButton
Implements Telegram Mini Apps Main Button.

Initialization
To initialize the component, use the initMainButton function:

typescript
import { initMainButton } from '@telegram-apps/sdk';

const [mainButton] = initMainButton();
Button Visibility
To control the Main Button visibility, developer could use such methods as show() and hide(). Both of them update component's isVisible property:

typescript
mainButton.show();
console.log(mainButton.isVisible); // true  

mainButton.hide();
console.log(mainButton.isVisible); // false
Loader
The Main Button could display a loader inside of it. To control its visibility, use showLoader() and hideLoader() methods. The isLoaderVisible property will be changed.

typescript
mainButton.showLoader();
console.log(mainButton.isLoaderVisible); // true  

mainButton.hideLoader();
console.log(mainButton.isLoaderVisible); // false
Active State
The Main Button can be enabled and disabled by calling disable() and enable() methods. Both of the methods will update the isEnabled property.

typescript
mainButton.enable();
console.log(mainButton.isEnabled); // true  

mainButton.disable();
console.log(mainButton.isEnabled); // false
Enabling the Main Button will allow a user to click it. As the result, the Main Button will receive the click event.

Background Color
To update the Main Button background color, use the setBackgroundColor(color: RGB) method. It will update the backgroundColor property.

typescript
mainButton.setBackgroundColor('#ffffaa');
console.log(mainButton.color); // '#ffffaa'
Text Color
To update the Main Button text color, use the setTextColor(color: RGB) method. It will update the textColor property.

typescript
mainButton.setTextColor('#cca233');
console.log(mainButton.textColor); // '#cca233'
Text
To update the Main Button text, use the setText(text: string) method. It will update the text property.

typescript
mainButton.setText('Submit');
console.log(mainButton.text); // 'Submit'
Setting Multiple Properties
Sometimes, a consecutive set of several Main Button parameters may lead to problematic artifacts in the UI. To avoid this issue, it is allowed to use the setParams method:

typescript
mainButton.setParams({
  backgroundColor: '#aa1388',
  text: 'Stop',
  isVisible: true,
});
Events
List of events, which could be tracked:

Event	Listener	Triggered when
click	() => void	Main Button was clicked
change	() => void	Something in component changed
change:backgroundColor	(value: RGB) => void	backgroundColor property changed
change:isLoaderVisible	(value: boolean) => void	isLoaderVisible property changed
change:isEnabled	(value: boolean) => void	isEnabled property changed
change:isVisible	(value: boolean) => void	isVisible property changed
change:text	(value: string) => void	text property changed
change:textColor	(value: RGB) => void	textColor property changed

#MiniApp
The component which provides the common Telegram Mini Apps functionality not covered by other system components.

Initialization
To initialize the component, use the initMiniApp function:

typescript
import { initMiniApp } from '@telegram-apps/sdk';

const [miniApp] = initMiniApp();
Colors
Header
Developer is able to get and update Mini App header and background colors. To get current value of header color, developer could refer to the headerColor property and update it via setHeaderColor method:

typescript
miniApp.setHeaderColor('secondary_bg_color');
// or starting from v6.10:
miniApp.setHeaderColor('#aa1132');
Background
As well as Mini App header color, developer is also able to manipulate its background color:

typescript
miniApp.setBgColor('#888311');
Mini App background color is used to determine if current Mini App has dark palette. To know if current palette is dark, developer should use isDark property:

typescript
console.log(miniApp.isDark); // false
Access Requests
Starting from Telegram Mini Apps version 6.9, Mini Apps are allowed to request access to the phone number and request access to write the current user. To do so, developers are allowed to use the requestPhoneAccess and requestWriteAccess methods:

typescript
miniApp.requestPhoneAccess().then(() => {
  // done.
});

miniApp.requestWriteAccess().then(() => {
  // done.
});
To request the contact information (the phone number, for example), utilize the requestContact method:

typescript
miniApp.requestContact().then(contact => {
  console.log(contact);
  // Output:
  // {
  //   authDate: Date(...),
  //   hash: '...',
  //   contact: {
  //     firstName: '...',
  //     phoneNumber: '+38291789233',
  //   },
  // };
});
Inline Mode
Mini Apps are available to be launched in inline mode. When a Mini App is launched in such a mode, the developer is allowed to use the switchInlineQuery method:

typescript
miniApp.switchInlineQuery('Show me something', ['users', 'groups']);
When calling this method, the Telegram application sends the bot username and the specified text to the chat selected by the user. The list of available chats will be restricted by the chat types specified in the second argument.

To check if the current Mini App is launched in inline mode, the developer should refer to the isBotInline property:

typescript
console.log(miniApp.isBotInline); // false
Lifecycle Methods
ready
Informs the Telegram app that the Mini App is ready to be displayed.

It is recommended to call this method as early as possible, as soon as all essential interface elements loaded. Once this method called, the loading placeholder is hidden and the Mini App shown.

If the method not called, the placeholder will be hidden only when the page fully loaded.

typescript
miniApp.ready();
close
Closes the Mini App.

typescript
miniApp.close();
If you would like to wrap the application into the bottom app bar, but not to close it, consider using the first argument returnBack: boolean.

ts
// Will wrap the application into the bottom app bar.
miniApp.close(true);
Other Methods
sendData
A method used to send data to the bot. When this method is called, a service message is sent to the bot containing data of a length up to 4096 bytes, and the Mini App is closed. Refer to the web_app_data field in the Message class.

Events
List of events, which could be tracked:

Event	Listener	Triggered when
change	() => void	Something in component changed
change:bgColor	(value: RGB) => void	bgColor property changed
change:headerColor	(value: HeaderColorKey or RGB) => void	headerColor property changed
Methods Support
List of methods and parameters, which could be used in support checks: requestWriteAccess, requestPhoneAccess, switchInlineQuery, setHeaderColor, setBgColor and setHeaderColor.color.

#SwipeBehavior
Implements Telegram Mini Apps swipe behavior functionality.

Initialization
To initialize the component, use the initSwipeBehavior function:

typescript
import { initSwipeBehavior } from '@telegram-apps/sdk';

const [swipeBehavior] = initSwipeBehavior();
Vertical Swipe
By default, users are allowed to hide the application just by swiping the application down. To prevent a possible closure, you can disable this behavior by calling the disableVerticalSwipe() method, or enable via the enableVerticalSwipe() method. In turn, both of these methods update the isVerticalSwipeEnabled property:

typescript
swipeBehavior.enableVerticalSwipe();
console.log(swipeBehavior.isVerticalSwipeEnabled); // true  

swipeBehavior.disableVerticalSwipe();
console.log(swipeBehavior.isVerticalSwipeEnabled); // false
Events
List of events, which could be tracked:

Event	Listener	Triggered when
change	() => void	Something in component changed
change:isVerticalSwipeEnabled	(value: boolean) => void	isVerticalSwipeEnabled property changed
Methods Support
List of methods, which could be used in support checks: disableVerticalSwipe, enableVerticalSwipe.

#ThemeParams
The component which contains an information about currently used theme by the Telegram application.

Initialization
To initialize the component, use the initThemeParams function:

typescript
import { initThemeParams } from '@telegram-apps/sdk';

const [themeParams] = initThemeParams();
Requesting Actual Data
To get the actual theme parameters information, developer could use the requestThemeParams function:

typescript
import { requestThemeParams } from '@telegram-apps/sdk';

requestThemeParams.then(console.log);

// Output:
// { bgColor: '#ffaabb', ... }
Colors
The developer can retrieve the theme color by using the get method:

typescript
themeParams.get('bgColor');
themeParams.get('packageUnknownColor');
To retrieve all colors via one object, use getState method:

typescript
themeParams.getState();
// Output:
// {
//   accentTextColor: '#aa1399',
//   bgColor: '#baac12',
//   linkColor: '#887722'
//   packageUnknownColor: '#676767,
// }
The ThemeParams component provides direct access to the list of colors:

accentTextColor: RGB | undefined
bgColor: RGB | undefined
buttonColor: RGB | undefined
buttonTextColor: RGB | undefined
destructiveTextColor: RGB | undefined
headerBgColor: RGB | undefined
hintColor: RGB | undefined
linkColor: RGB | undefined
secondaryBgColor: RGB | undefined
sectionBgColor: RGB | undefined
sectionHeaderTextColor: RGB | undefined
subtitleTextColor: RGB | undefined
textColor: RGB | undefined
Example:

typescript
themeParams.accentTextColor; // '#aa1399'
Events
List of events, which could be tracked:

Event	Listener	Triggered when
change	() => void	Something in component changed
change:{theme_key}	(value: RGB) => void	Color with specified key changed

#Utils
Implements functionality that doesn't require state and can't be categorized.

Initialization
To initialize the component, use the initUtils function:

typescript
import { initUtils } from '@telegram-apps/sdk';

const utils = initUtils();
Links
openLink
MiniApp class is capable of opening links of different types. For example, it can open a link in an external browser not closing current Mini App, using method openLink:

typescript
utils.openLink('https://google.com');
This method also allows opening a link using Telegram's Instant View when possible:

typescript
utils.openLink('https://google.com', { tryInstantView: true });
To try opening a link using a user preferred browser, use the tryBrowser option:

typescript
utils.openLink('https://google.com', { tryBrowser: true });
openTelegramLink
In case, a developer would like to open a link related to Telegram (starting with https://t.me) the method openTelegramLink can be used.

Using this method, the Telegram application will handle such a link on its own side:

typescript
utils.openTelegramLink('https://t.me/heyqbnk');
shareURL
Sharing a URL is a common functionality in mini applications. To achieve this, a developer can use the shareURL method, which accepts the URL to be shared and optional text to append to the message after the URL.

When called, it opens the chat selector to share the URL.

ts
utils.shareURL('https://t.me/mybot/myapp', 'Look! Some cool app here!');
WARNING

Currently, there is no native method to share anything directly. Therefore, this method utilizes the openTelegramLink method, which closes the app after being called. This method uses Share links under the hood.

Clipboard
Developers are allowed to read the text from the clipboard using the readTextFromClipboard method.

This method reads text from the clipboard and returns a string or null. Null is returned in cases:

The value in the clipboard is not text.
Access to the clipboard is not allowed.
typescript
utils.readTextFromClipboard().then((data) => {
  console.log('Clipboard data:', data);
  // Output: string or null
});
Methods Support
List of methods and parameters, which could be used in support checks: readTextFromClipboard and openLink.tryInstantView

#Viewport
Implements Telegram Mini Apps viewport functionality.

Initialization
To initialize the component, use the initViewport function:

typescript
import { initViewport } from '@telegram-apps/sdk';

const [viewport] = initViewport();
INFO

Since Viewport can't be instantiated synchronously, this function returns a promise as the first value in the tuple that will be resolved when the actual viewport state is retrieved.

Dimensions
The application can display just the top part of the Mini App, with its lower part remaining outside the screen area. From this position, the user can "pull" the Mini App to its maximum height, while the developer can do the same by calling expand method (use isExpanded prop to get current expansion state). As the position of the Mini App changes, the current height value of the visible area will be updated in real time.

INFO

Please note that the refresh rate of this value (height) is not sufficient to smoothly follow the lower border of the window. It should not be used to pin interface elements to the bottom of the visible area. It's more appropriate to use the value of the stableHeight field for this purpose.

Requesting Actual Data
To get actual viewport information, developer could use requestViewport function:

typescript
import {requestViewport} from '@telegram-apps/sdk';

requestViewport().then((data) => {
    // Output:
    // { height: 122, isExpanded: false, width: 375, isStateStable: true }
    console.log(data);
});
Events
List of events, which could be tracked:

Event	Listener	Triggered when
change	() => void	Something in component changed
change:height	(height: number) => void	height property changed
change:isExpanded	(isExpanded: boolean) => void	isExpanded property changed
change:stableHeight	(stableHeight: boolean) => void	stableHeight property changed
change:width	(width: boolean) => void	width property changed

#BrowserNavigator
BrowserNavigator is a class that implements navigation using the browser's History API. This navigator extends the standard one, providing basic navigation functionality and logic specific to the browser's history.

Constructor
To create an instance of this class, developers can use the class constructor, which accepts history items, a cursor (index) pointing to the entry in the history items list, and additional options:

typescript
import { BrowserNavigator } from '@telegram-apps/sdk';

new BrowserNavigator(['/index'], 0);
new BrowserNavigator([{ pathname: '/a' }, { pathname: '/b' }], 1);
WARNING

If an empty history items list or a cursor pointing to a non-existent item is passed, the constructor will throw an appropriate error.

postEvent
The postEvent function allows replacing a function that calls Mini Apps methods on behalf of the navigator.

ts
const n = new BrowserNavigator(['/'], 0, {
  postEvent(method, payload) {
    console.log('postEvent:', method, payload);
  },
});
hashMode
The hashMode property allows a developer to set the navigation mode used by the navigator. Allowed values are classic (#pathname), slash (#/pathname), and null. Passing the null value switches the navigator from SPA mode to MPA mode, using the entire href instead of the hash part of the location.

By default, the navigator uses the classic mode.

ts
const n = new BrowserNavigator(['/'], 0, {
  hashMode: 'slash'
});
base
The base property is responsible for parsing routes and rendering paths assuming that they must start with the specified base value.

ts
const n = new BrowserNavigator(['/'], 0, {
  hashMode: null,
  base: '/solidjs-template',
});

n.renderPath('/home'); // -> /solidjs-template/home
This value is only useful when you are using the MPA mode.

createBrowserNavigatorFromLocation
To simplify the process of creating BrowserNavigator, the package provides the createBrowserNavigatorFromLocation method. Depending on the options (which are constructor options described previously) passed, it parses the current location and creates a BrowserNavigator instance.

typescript
import { createBrowserNavigatorFromLocation } from '@telegram-apps/sdk';

const navigator = createBrowserNavigatorFromLocation({
  hashMode: 'slash',
});
initNavigator
The initNavigator function is responsible for creating a BrowserNavigator instance using previously saved navigator state. It also automatically saves it in the session storage for future state restoration.

This function accepts session storage key name, which will contain navigator's state and an optional object, representing navigator constructor options.

ts
import { initNavigator } from '@telegram-apps/sdk';

const n = initNavigator('app-navigator-state', {
  hashMode: 'slash',
});
In case, the function was unable to restore the navigator using the session storage, it will utilize the createBrowserNavigatorFromLocation function.

Attaching
Creating an instance of BrowserNavigator and using its methods doesn't automatically update the browser history. To achieve this, developers should attach it. Until then, the navigator will only update its internal state and notify all its subscribers about changes. Manual attachment is necessary to prevent situations where several navigators of this type are created, each trying to control the browser history with its internal state.

To allow the navigator to control the browser's history, it is required to attach it via the attach method:

typescript
import { BrowserNavigator } from '@telegram-apps/sdk';

const navigator = new BrowserNavigator(...);

navigator.attach().then(() => {
  console.log('Attachment completed');
});
This method returns a promise that will be resolved when the attachment is completed.

To stop the navigator from modifying the browser's history, use the detach method:

typescript
navigator.detach();
Navigating
The navigator provides a list of methods for developers to manipulate the navigation history.

back
Goes back in history by 1.

typescript
navigator.back();
forward
Goes forward in history by 1.

typescript
navigator.forward();
go
Changes the currently active history item index by the specified delta. This method doesn't change the index if the updated index points to a non-existing history item. This behavior is preserved until the fit argument is specified. If it is specified, the method adjusts the passed delta to fit within the bounds [0, history.length - 1].

typescript
// Goes back in history by 3 entries.
navigator.go(-3);

// Will surely do nothing in real-world applications.
navigator.go(-100000);

// Will go back to the oldest entry.
navigator.go(-100000, true);

// Will go forward to the newest entry.
navigator.go(100000, true);
goTo
Goes to the specified index. The method does nothing if the passed index is out of bounds.

If the fit option is specified and the index is out of bounds, it will be adjusted to the nearest bound.

typescript
// Will do nothing.
navigator.goTo(-1);

// Will go to the oldest entry.
navigator.goTo(0);

// Will surely do nothing in real-world applications.
navigator.goTo(100000);

// Will go back to the oldest entry.
navigator.goTo(-100000, true);

// Will go forward to the newest entry.
navigator.goTo(100000, true);
push
Pushes a new history item. The method replaces all entries after the current one with the one being pushed. Note that the passed item is always relative. If you want to use it as an absolute one, use the / prefix. Example: /absolute, { pathname: '/absolute' }.

To create a final path, the navigator uses a method, used in the URL class constructor, resolving a path based on the current one.

In the upcoming examples, let's assume that the current entry is /home/blog.

Absolute pathname
Specifying an absolute path will not merge it with the current one; instead, it will be used in its entirety:

typescript
navigator.push('/database');
// or
navigator.push({ pathname: '/database' });
// Navigator will add a new entry, and the current one becomes /database
Relative pathname
Specifying a relative pathname will exhibit the same behavior as in the browser:

typescript
navigator.push('license');
// or
navigator.push({ pathname: 'license' });
// Navigator will add a new entry, and the current one becomes /home/license
Search
To add an entry with query parameters, use a question mark (?) or the search entry property:

typescript
navigator.push('?id=1');
// or
navigator.push({ search: '?id=1' });
// Navigator will add a new entry, and the current one becomes /home/blog?id=1
INFO

Pushing a new pathname with different or missing query parameters will result in the loss of current query parameters. To prevent this, the developer should pass them again.

Hash
Adding the hash part of the entry follows the same logic as search, but using a hashtag (#) and the hash entry property.

typescript
navigator.push('#introduction');
// or
navigator.push({ hash: '#introduction' });
// Navigator will add a new entry, and the current 
// one becomes /home/blog#introduction
replace
The replace method functions similarly to the push method, but it doesn't create a new entry. Instead, it replaces the current one.

Properties
index
Current history cursor.

typescript
const navigator = new BrowserNavigator(['/'], 0);
navigator.index; // 0
id
Current history item identifier. The navigator generates them itself if an id is not specified explicitly.

typescript
const navigator = new BrowserNavigator(['/'], 0);
navigator.id; // 'abb721'

const navigator2 = new BrowserNavigator([{ id: 'a', pathname: '/' }], 0);
navigator2.id; // 'a'
hash
Current history item hash.

typescript
const navigator = new BrowserNavigator(['/#jungle'], 0);
navigator.hash; // "#jungle"
hasPrev
True if the navigator has items before the current item.

typescript
const navigator = new BrowserNavigator(['/'], 0);
navigator.hasPrev; // false

const navigator2 = new BrowserNavigator(['/a', '/b'], 1);
navigator2.hasPrev; // true
hasNext
True if the navigator has items after the current item.

typescript
const navigator = new BrowserNavigator(['/'], 0);
navigator.hasNext; // false

const navigator2 = new BrowserNavigator(['/a', '/b'], 0);
navigator2.hasNext; // true
history
Safe to modify navigation history.

typescript
const navigator = new BrowserNavigator(['/a#a-hash', '/b?b-query=1'], 0);
navigator.history;
// [
//   { pathname: '/a', hash: '#a-hash', search: '', id: 'ahJJ123' },
//   { pathname: '/b', hash: '', search: '?b-query=1', id: 'dd82' },
// ]
path
Path, including pathname, search, and hash.

typescript
const navigator = new BrowserNavigator([{
  pathname: '/a',
  hash: '#mama',
  search: '?joe',
}], 0);
navigator.path; // '/a?joe#mama'
pathname
Current pathname. Always starts with a slash.

typescript
const navigator = new BrowserNavigator([{
  pathname: '/a',
  hash: '#mama',
  search: '?joe',
}], 0);
navigator.pathname; // '/a'
search
Current query parameters.

typescript
const navigator = new BrowserNavigator([{
  pathname: '/a',
  hash: '#mama',
  search: '?joe',
}], 0);
navigator.search; // '?joe'
state
Current history item state.

typescript
const navigator = new BrowserNavigator([{ state: 'test' }], 0);


navigator.state; // 'test'
Events
BrowserNavigator provides on and off methods to manage event listeners. Currently, the only event available for listening is change. The change event's payload is an object containing the following properties:

navigator: BrowserNavigator: The related navigator instance.
delta: number: The delta of the currently active item cursor.
from: { pathname: string; hash: string; search: string; id: string; state?: State }: The previously active history item.
to: An object with the same structure as from, representing the currently active history item.
Adding an Event Listener
To add an event listener for the change event, use the on method:

typescript
const removeEventListener = navigator.on('change', (ev) => {
  console.warn('Navigation state changed', ev);
});
Removing an Event Listener
To remove an event listener, call the function returned by the on method:

typescript
removeEventListener();
Alternatively, you could use the navigator's off method:

typescript
function listener(ev) {
  console.warn('Navigation state changed', ev);
}
navigator.on('change', listener);
navigator.off('change', listener);
Other Methods
renderPath
The renderPath method combines the navigator's base property with the given path data, applying the navigator's navigation mode. This method returns the fully rendered path as a string.

typescript
const n = new BrowserNavigator(['/'], 0, {
  hashMode: 'slash',
});
n.renderPath('/test'); // '#/test'

const n2 = new BrowserNavigator(['/'], 0, {
  base: '/my-base',
  hashMode: 'slash',
});
n2.renderPath('/test'); // '#/my-base/test'

const n3 = new BrowserNavigator(['/'], 0, {
  base: '/my-base',
  hashMode: null,
});
n3.renderPath('/test'); // '/my-base/test'
parsePath
The parsePath method parses the provided path according to the current navigation type and returns it as an object. This method helps to understand how the navigator interprets the given path.

typescript
const n = new BrowserNavigator(['/'], 0);
n.parsePath('/test');
// { pathname: '/', search: '', hash: '' }

n.parsePath('/test#abc');
// { pathname: '/abc', search: '', hash: '' }

n.parsePath('/test#abc?query#some-hash');
// { pathname: '/abc', search: '?query', hash: '#some-hash' }

const n2 = new BrowserNavigator(['/'], 0, { hashMode: null });
n2.parsePath('/test');
// { pathname: '/test', search: '', hash: '' }

n2.parsePath('/test#abc');
// { pathname: '/test', search: '', hash: '#abc' }

n2.parsePath('/test?query#abc');
// { pathname: '/test', search: '?query', hash: '#abc' }

#@telegram-apps/react-router-integration



Telegram Mini Apps Navigator integration for react-router-dom.

Installation

pnpm

npm

yarn
bash
pnpm i @telegram-apps/react-router-integration
Usage
At the moment, this package provides the only 1 function, which creates the integration for react-router-dom Router - useIntegration.

Here is how it could be used:

jsx
import { useIntegration } from '@telegram-apps/react-router-integration';
import { initNavigator } from '@telegram-apps/sdk-react';
import { useEffect, useMemo } from 'react';
import {
  Navigate,
  Route,
  Router,
  Routes,
} from 'react-router-dom';

import { IndexPage } from './IndexPage.js';

function App() {
  // Create a new application navigator and attach it to the browser history, so it could modify
  // it and listen to its changes.
  const navigator = useMemo(() => initNavigator('app-navigation-state'), []);
  const [location, reactNavigator] = useIntegration(navigator);

  // Don't forget to attach the navigator to allow it to control the BackButton state as well
  // as browser history.
  useEffect(() => {
    navigator.attach();
    return () => navigator.detach();
  }, [navigator]);

  return (
    <Router location={location} navigator={reactNavigator}>
      <Routes>
        <Route path={'/'} component={IndexPage}/>
        <Route path={'*'} element={<Navigate href={'/'}/>}/>
      </Routes>
    </Router>
  );
}
You can learn more about how to use it real world applications using our React template.

My app codes: 

components/App.tsx:

import React, { useEffect, useMemo } from 'react';
import { Navigate, Route, Router, Routes } from 'react-router-dom';
import { useIntegration } from '@telegram-apps/react-router-integration';
import {
  bindMiniAppCSSVars,
  bindThemeParamsCSSVars,
  bindViewportCSSVars,
  initNavigator,
  useLaunchParams,
  useMiniApp,
  useThemeParams,
  useViewport,
} from '@telegram-apps/sdk-react';
import { AppRoot, Progress } from '@telegram-apps/telegram-ui';
import { routes } from '@/navigation/routes.tsx';
import { usePreloadImages } from '@/hooks/usePreloadImages';
import MainLogo from '../assets/logo.svg';

export const App: React.FC = () => {
  const launchParams = useLaunchParams();
  const miniApp = useMiniApp();
  const themeParams = useThemeParams();
  const viewport = useViewport();

  const { progress, loaded } = usePreloadImages([MainLogo]);

  useEffect(() => {
    bindMiniAppCSSVars(miniApp, themeParams);
    bindThemeParamsCSSVars(themeParams);
    if (viewport) {
      bindViewportCSSVars(viewport);
    }
  }, [miniApp, themeParams, viewport]);

  const navigator = useMemo(() => initNavigator('app-navigation-state'), []);
  const [location, reactNavigator] = useIntegration(navigator);

  useEffect(() => {
    navigator.attach();
    return () => navigator.detach();
  }, [navigator]);

  if (!launchParams || !miniApp || !themeParams || !loaded) {
    return (
      <AppRoot>
        <Progress value={progress} />
      </AppRoot>
    );
  }

  return (
    <AppRoot appearance={miniApp.isDark ? 'dark' : 'light'} platform={['macos', 'ios'].includes(launchParams.platform) ? 'ios' : 'base'}>
      <Router location={location} navigator={reactNavigator}>
        <Routes>
          {routes.map((route) => (
            <Route key={route.path} {...route} />
          ))}
          <Route path="*" element={<Navigate to="/" />} />
        </Routes>
      </Router>
    </AppRoot>
  );
};

export default App;

usePreloadImages.ts:

import { useState, useEffect } from 'react';

export const usePreloadImages = (imageUrls: string[]) => {
  const [progress, setProgress] = useState(0);
  const [loaded, setLoaded] = useState(false);

  useEffect(() => {
    let isMounted = true;
    const totalImages = imageUrls.length;

    const loadImage = (url: string) => {
      return new Promise<void>((resolve, reject) => {
        const img = new Image();
        img.src = url;
        img.onload = () => {
          if (isMounted) {
            setProgress((prevProgress) => prevProgress + (100 / totalImages));
          }
          resolve();
        };
        img.onerror = () => reject(new Error(`Failed to load image: ${url}`));
      });
    };

    Promise.all(imageUrls.map(loadImage))
      .then(() => {
        if (isMounted) setLoaded(true);
      })
      .catch((error) => {
        console.error(error);
        if (isMounted) setLoaded(true); 
      });

    return () => {
      isMounted = false;
    };
  }, [imageUrls]);

  return { progress, loaded };
};

index.tsx:

import ReactDOM from 'react-dom/client';

import { Root } from '@/components/Root';

// Uncomment this import in case, you would like to develop the application even outside
// the Telegram application, just in your browser.
import './mockEnv.ts';

import '@telegram-apps/telegram-ui/dist/styles.css';
import './index.scss';

ReactDOM.createRoot(document.getElementById('root')!).render(<Root/>);

src/pages/StartPage.tsx:

import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import MainLogo from '../../assets/logo.svg';
import { AppRoot, Section, Image, Button, FixedLayout, Spinner } from '@telegram-apps/telegram-ui';
import { useHapticFeedback } from '@telegram-apps/sdk-react';
import { motion } from 'framer-motion';
import './StartPage.scss';

const StartPage: React.FC = () => {
  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();
  const hapticFeedback = useHapticFeedback();

  const handleStart = () => {
    setLoading(true);
    hapticFeedback.impactOccurred('medium');
    setTimeout(() => {
      setLoading(false);
      navigate('/registration');
    }, 1000);
  };

  return (
    <AppRoot>
      <FixedLayout vertical="top" className="full-screen">
        <Section className="logo-container">
          <motion.div
            initial={{ opacity: 0, scale: 0.8 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={{ duration: 0.5, ease: 'easeInOut' }}
          >
            <Image src={MainLogo} alt="App Logo"/>
          </motion.div>
        </Section>
        <FixedLayout vertical="bottom" className="button-layout">
          <Button className="start-button" onClick={handleStart} style={{ background: '#1375FA', height: '58px' }}>
            {loading ? <Spinner size="m" className='spinner'/> : 'Начать'}
          </Button>
        </FixedLayout>
      </FixedLayout>
    </AppRoot>
  );
};

export default StartPage;

src/pages/RegistrationPage.tsx:

import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { motion } from 'framer-motion';
import {
  AppRoot,
  FixedLayout,
  Section,
  Text,
  Input,
  Button,
  Caption,
  Headline,
  Spinner
} from '@telegram-apps/telegram-ui';
import { useHapticFeedback } from '@telegram-apps/sdk-react';
import checkIcon from '../../assets/checked.svg';
import errorIcon from '../../assets/wrong.svg';
import './RegistrationPage.scss';

const validateName = (name: string) => /^[A-ZА-ЯЁ][a-zа-яё]+\s[A-ZА-ЯЁ][a-zа-яё]+$/.test(name);
const validatePhoneNumber = (number: string) => /^(\+7|7|8)?[\s-]?\(?\d{3}\)?[\s-]?\d{3}[\s-]?\d{2}[\s-]?\d{2}$/.test(number);
const validateEmail = (email: string) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
const validateINN = (inn: string) => /^\d{12}$/.test(inn);

const RegistrationPage: React.FC = () => {
  const [formData, setFormData] = useState({
    name: '',
    phone: '',
    email: '',
    inn: '',
  });

  const [formErrors, setFormErrors] = useState({
    name: false,
    phone: false,
    email: false,
    inn: false,
  });

  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();
  const hapticFeedback = useHapticFeedback();

  const handleChange = (field: string, value: string) => {
    setFormData((prevData) => ({
      ...prevData,
      [field]: value,
    }));

    switch (field) {
      case 'name':
        setFormErrors((prevErrors) => ({
          ...prevErrors,
          name: !validateName(value),
        }));
        break;
      case 'phone':
        setFormErrors((prevErrors) => ({
          ...prevErrors,
          phone: !validatePhoneNumber(value),
        }));
        break;
      case 'email':
        setFormErrors((prevErrors) => ({
          ...prevErrors,
          email: !validateEmail(value),
        }));
        break;
      case 'inn':
        setFormErrors((prevErrors) => ({
          ...prevErrors,
          inn: !validateINN(value),
        }));
        break;
      default:
        break;
    }
  };

  const handleSubmit = () => {
    const errors = {
      name: !validateName(formData.name),
      phone: !validatePhoneNumber(formData.phone),
      email: !validateEmail(formData.email),
      inn: !validateINN(formData.inn),
    };
    setFormErrors(errors);

    const hasErrors = Object.values(errors).some((error) => error);
    if (!hasErrors) {
      setLoading(true);
      hapticFeedback.impactOccurred('medium'); // Trigger haptic feedback
      setTimeout(() => {
        setLoading(false);
        navigate('/documents');
      }, 1000);
    }
  };

  const getStatusIcon = (hasError: boolean) => {
    return (
      <motion.img
        src={hasError ? errorIcon : checkIcon}
        alt={hasError ? 'Error' : 'Checked'}
        className="status-icon"
        initial={{ opacity: 0, scale: 0.8 }}
        animate={{ opacity: 1, scale: 1 }}
        exit={{ opacity: 0, scale: 0.8 }}
        transition={{ duration: 0.3, ease: 'easeInOut' }}
      />
    );
  };

  return (
    <AppRoot>
      <FixedLayout vertical="top" className="full-screen">
        <Section className='register-layout'>
          <Section className='register-content'>
            <Headline weight="3" Component={'h1'}>Регистрация</Headline>
          </Section>
          <Section className="form-body">
            <Section className="form-item">
              <Text weight="3" Component="span" className="input-label">
                Введите вашу Ф.И.О
              </Text>
              <Input
                placeholder="Иванов Иван Иванович"
                className={`form-input ${formErrors.name ? 'error' : ''}`}
                value={formData.name}
                onChange={(e) => handleChange('name', e.currentTarget.value)}
                after={formData.name && getStatusIcon(formErrors.name)}
              />
            </Section>
            <Section className="form-item">
              <Text weight="3" Component="span" className="input-label">
                Введите ваш номер телефона
              </Text>
              <Input
                placeholder="+7 (000) 000 00 00"
                className={`form-input ${formErrors.phone ? 'error' : ''}`}
                value={formData.phone}
                onChange={(e) => handleChange('phone', e.currentTarget.value)}
                after={formData.phone && getStatusIcon(formErrors.phone)}
              />
            </Section>
            <Section className="form-item">
              <Text weight="3" Component="span" className="input-label">
                Введите ваш e-mail
              </Text>
              <Input
                placeholder="e-mail"
                className={`form-input ${formErrors.email ? 'error' : ''}`}
                value={formData.email}
                onChange={(e) => handleChange('email', e.currentTarget.value)}
                after={formData.email && getStatusIcon(formErrors.email)}
              />
            </Section>
            <Section className="form-item">
              <Text weight="3" Component="span" className="input-label">
                Введите ИНН
              </Text>
              <Input
                placeholder="ИНН"
                className={`form-input ${formErrors.inn ? 'error' : ''}`}
                value={formData.inn}
                onChange={(e) => handleChange('inn', e.currentTarget.value)}
                after={formData.inn && getStatusIcon(formErrors.inn)}
              />
              {formErrors.inn && (
                <Caption level="1" Component="p" style={{ color: 'red' }}>
                  Количество цифр должно быть ровно 12
                </Caption>
              )}
            </Section>
          </Section>
        </Section>
        <FixedLayout vertical="bottom" className="bottom-data">
          <Section className="agree-data">
            <Caption level="1" Component="p">
              Нажимая на кнопку “Продолжить” я даю согласие на
              <span style={{ color: '#3586FF', marginLeft: '5px' }}>
                обработку персональных данных
              </span>
            </Caption>
          </Section>
          <Button
            className="start-button"
            style={{ background: '#1375FA', height: '58px' }}
            onClick={handleSubmit}
          >
            {loading ? <Spinner size="m" /> : 'Начать'}
          </Button>
        </FixedLayout>
      </FixedLayout>
    </AppRoot>
  );
};

export default RegistrationPage;

src/pages/DocumentPage.tsx:

import React from 'react';
import MainLogo from '../../assets/logo.svg';
import { AppRoot, Section, Image, FixedLayout, Text, InlineButtons } from '@telegram-apps/telegram-ui';
import './DocumentPage.scss';
import IconInbox from '../../assets/icon_inbox.svg';
import IconOutBox from '../../assets/icon_outbox.svg';

const DocumentPage: React.FC = () => {
  return (
    <AppRoot>
      <FixedLayout vertical="top" className="full-document-screen">
        <Section className="logo-container">
          <Section>
            <Image src={MainLogo} alt="App Logo" className="document-logo" />
          </Section>
        </Section>
        <Section className="new-contract-section">
          <InlineButtons mode="plain" className='docs-buttons'>
            <InlineButtons.Item className='docs-button'>
              <Image src={IconInbox} alt="Inbox Icon" />
              <Text weight='3'>Входящие</Text>
            </InlineButtons.Item>
            <InlineButtons.Item className='docs-button'>
              <Image src={IconOutBox} alt="Outbox Icon" />
              <Text weight='3'>Исходящие</Text>
            </InlineButtons.Item>
          </InlineButtons>
        </Section>
      </FixedLayout>
    </AppRoot>
  );
};

export default DocumentPage;


Root.tsx:

import { SDKProvider } from '@telegram-apps/sdk-react';
import { type FC } from 'react';

import { App } from './App';
import { ErrorBoundary } from '@/components/ErrorBoundary.tsx';

const ErrorBoundaryError: FC<{ error: unknown }> = ({ error }) => (
  <div>
    <p>An unhandled error occurred:</p>
    <blockquote>
      <code>
        {error instanceof Error
          ? error.message
          : typeof error === 'string'
            ? error
            : JSON.stringify(error)}
      </code>
    </blockquote>
  </div>
);

const Inner: FC = () => {

  return (
      <SDKProvider acceptCustomStyles>
        <App/>
      </SDKProvider>
  );
};

export const Root: FC = () => (
  <ErrorBoundary fallback={ErrorBoundaryError}>
    <Inner/>
  </ErrorBoundary>
);

ErrorBoundary.tsx:

import {
  Component,
  type ComponentType,
  type GetDerivedStateFromError,
  type PropsWithChildren,
  type ReactNode,
} from 'react';

export interface ErrorBoundaryProps extends PropsWithChildren {
  fallback?: ReactNode | ComponentType<{ error: unknown }>;
}

interface ErrorBoundaryState {
  error?: unknown;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  state: ErrorBoundaryState = {};

  // eslint-disable-next-line max-len
  static getDerivedStateFromError: GetDerivedStateFromError<ErrorBoundaryProps, ErrorBoundaryState> = (error) => ({ error });

  componentDidCatch(error: Error) {
    this.setState({ error });
  }

  render() {
    const {
      state: {
        error,
      },
      props: {
        fallback: Fallback,
        children,
      },
    } = this;

    return 'error' in this.state
      ? typeof Fallback === 'function'
        ? <Fallback error={error} />
        : Fallback
      : children;
  }
}
